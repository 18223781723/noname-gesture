(function () { 'use strict'; function a(a, b) { this.element = a, this.options = b, this.point = { x: 0, y: 0 }, this.point2 = { x: 0, y: 0 }, this.lastPoint = { x: 0, y: 0 }, this.distance = { x: 0, y: 0 }, this.lastDistance = { x: 0, y: 0 }, this.lastMove = { x: 0, y: 0 }, this.lastCenter = { x: 0, y: 0 }, this.lastRotate = 0, this.lastScale = 1, this.tapCount = 0, this.points = [], this.pointers = [], this.dragDirection = "", this.isPointerDown = !1, this.singleTapTimeout = null, this.longTapTimeout = null, this.rafId = null, this.bindEventListener() } a.prototype.handlePointerDown = function (a) { a.preventDefault(); 0 !== a.button || (this.element.setPointerCapture(a.pointerId), this.isPointerDown = !0, this.dragDirection = "", this.points = [], this.pointers.push(a), this.point = { x: this.pointers[0].clientX, y: this.pointers[0].clientY }, 1 === this.pointers.length ? (this.tapCount++, clearTimeout(this.singleTapTimeout), this.distance = { x: 0, y: 0 }, this.lastMove = { x: this.pointers[0].clientX, y: this.pointers[0].clientY }, 1 < this.tapCount && (30 < Math.abs(this.point.x - this.lastPoint.x) || 30 < Math.abs(this.point.y - this.lastPoint.y)) && (this.tapCount = 1), 1 === this.tapCount && (this.longTapTimeout = setTimeout(() => { this.tapCount = 0, this.options.longTap && this.options.longTap() }, 500))) : 2 === this.pointers.length && (this.tapCount = 0, clearTimeout(this.longTapTimeout), this.point2 = { x: this.pointers[1].clientX, y: this.pointers[1].clientY }, this.lastDistance = { x: this.distance.x, y: this.distance.y }, this.lastCenter = this.getCenter(this.point, this.point2), this.lastRotate = 0, this.lastScale = 1), this.lastPoint = { x: this.point.x, y: this.point.y }, this.options.pointerDown && this.options.pointerDown(a)) }, a.prototype.handlePointerMove = function (a) { if (this.isPointerDown) { this.handlePointers(a, "update"); const b = { x: this.pointers[0].clientX, y: this.pointers[0].clientY }; if (1 === this.pointers.length) this.distance = { x: b.x - this.point.x + this.lastDistance.x, y: b.y - this.point.y + this.lastDistance.y }, (10 < Math.abs(this.distance.x) || 10 < Math.abs(this.distance.y)) && (this.tapCount = 0, clearTimeout(this.longTapTimeout), "" === this.dragDirection && (this.dragDirection = this.getDragDirection())), this.points.unshift({ x: b.x, y: b.y, timeStamp: a.timeStamp }), 20 < this.points.length && this.points.pop(), this.handleDrag(a, b), this.lastMove = { x: b.x, y: b.y }; else if (2 === this.pointers.length) { const c = { x: this.pointers[1].clientX, y: this.pointers[1].clientY }; this.handleRotate(a, b, c), this.handlePinch(a, b, c) } this.options.pointerMove && this.options.pointerMove(a) } }, a.prototype.handlePointerUp = function (a) { this.isPointerDown && (this.handlePointers(a, "delete"), 0 === this.pointers.length ? (this.isPointerDown = !1, a._hasTriggerSwipe = !1, clearTimeout(this.longTapTimeout), 0 === this.tapCount ? this.handleSwipe(a) : (this.options.tap && this.options.tap(), 1 === this.tapCount ? this.singleTapTimeout = setTimeout(() => { this.tapCount = 0, this.options.singleTap && this.options.singleTap() }, 250) : 1 < this.tapCount && (this.tapCount = 0, this.options.doubleTap && this.options.doubleTap()))) : 1 === this.pointers.length && (this.point = { x: this.pointers[0].clientX, y: this.pointers[0].clientY }, this.lastMove = { x: this.pointers[0].clientX, y: this.pointers[0].clientY }), a._distanceX = this.distance.x, a._distanceY = this.distance.y, this.options.pointerUp && this.options.pointerUp(a)) }, a.prototype.handlePointerCancel = function (a) { this.isPointerDown = !1, this.tapCount = 0, clearTimeout(this.longTapTimeout), this.pointers = [], this.options.pointerCancel && this.options.pointerCancel(a) }, a.prototype.handlePointers = function (a, b) { for (let c = 0; c < this.pointers.length; c++)this.pointers[c].pointerId === a.pointerId && ("update" === b ? this.pointers[c] = a : "delete" == b && this.pointers.splice(c, 1)) }, a.prototype.getDragDirection = function () { let a = ""; return a = Math.abs(this.distance.x) > Math.abs(this.distance.y) ? 0 < this.distance.x ? "right" : "left" : 0 < this.distance.y ? "down" : "up", a }, a.prototype.handleDrag = function (a, b) { a._dragDirection = this.dragDirection, a._diffX = b.x - this.lastMove.x, a._diffY = b.y - this.lastMove.y, a._distanceX = b.x - this.point.x + this.lastDistance.x, a._distanceY = b.y - this.point.y + this.lastDistance.y, this.options.drag && this.options.drag(a) }, a.prototype.handleSwipe = function (a) { let b, c; for (const d of this.points) { if (200 < a.timeStamp - d.timeStamp) break; b = a.clientX - d.x, c = a.clientY - d.y } 20 < Math.abs(b) ? (a._swipeDirection = 0 < b ? "right" : "left", a._hasTriggerSwipe = !0) : 20 < Math.abs(c) && (a._swipeDirection = 0 < c ? "down" : "up", a._hasTriggerSwipe = !0), a._hasTriggerSwipe && this.options.swipe && this.options.swipe(a) }, a.prototype.handleRotate = function (a, b, c) { let d = this.getAngle(b, c) - this.getAngle(this.point, this.point2); a._rotate = d - this.lastRotate, this.lastRotate = d, this.options.rotate && this.options.rotate(a) }, a.prototype.handlePinch = function (a, b, c) { let d = this.getDistance(b, c) / this.getDistance(this.point, this.point2), e = this.getCenter(b, c); a._scale = d / this.lastScale, a._centerX = e.x, a._centerY = e.y, a._lastCenterX = this.lastCenter.x, a._lastCenterY = this.lastCenter.y, this.lastCenter = e, this.lastScale = d, this.options.pinch && this.options.pinch(a) }, a.prototype.bindEventListener = function () { this.handlePointerDown = this.handlePointerDown.bind(this), this.handlePointerMove = this.handlePointerMove.bind(this), this.handlePointerUp = this.handlePointerUp.bind(this), this.handlePointerCancel = this.handlePointerCancel.bind(this), this.element.addEventListener("pointerdown", this.handlePointerDown), this.element.addEventListener("pointermove", this.handlePointerMove), this.element.addEventListener("pointerup", this.handlePointerUp), this.element.addEventListener("pointercancel", this.handlePointerCancel) }, a.prototype.unbindEventListener = function () { this.element.removeEventListener("pointerdown", this.handlePointerDown), this.element.removeEventListener("pointermove", this.handlePointerMove), this.element.removeEventListener("pointerup", this.handlePointerUp), this.element.removeEventListener("pointercancel", this.handlePointerCancel) }, a.prototype.destroy = function () { this.unbindEventListener() }, a.prototype.getAngle = function (a, b) { const c = a.x - b.x, d = a.y - b.y; return 180 * Math.atan2(d, c) / Math.PI }, a.prototype.getDistance = function (a, b) { const c = a.x - b.x, d = a.y - b.y; return Math.hypot(c, d) }, a.prototype.getCenter = function (a, b) { const c = (a.x + b.x) / 2, d = (a.y + b.y) / 2; return { x: c, y: d } }, a.prototype.getImgSize = function (a, b, c, d) { let e, f; return a / b >= c / d ? a > c ? (e = c, f = c / a * b) : (e = a, f = b) : b > d ? (e = d / b * a, f = d) : (e = a, f = b), { width: e, height: f } }, a.prototype.easeOut = function (a, b, c, d) { return -(b - a) * (c /= d) * (c - 2) + a }, a.prototype.raf = function (a, b = 300) { function c(g) { e === void 0 && (e = g); let h = g - e; h > b && (h = b, f++), 1 >= f && (a(h), d.rafId = window.requestAnimationFrame(c)) } const d = this; let e, f = 0; this.rafId = window.requestAnimationFrame(c) }, "function" == typeof define && define.amd ? define(function () { return a }) : "object" == typeof module && "object" == typeof exports ? module.exports = a : window.NonameGesture = a })();