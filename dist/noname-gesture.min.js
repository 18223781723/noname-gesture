(function () { 'use strict'; function a(a, b) { this.element = a, this.options = b, this.point1 = { x: 0, y: 0 }, this.point2 = { x: 0, y: 0 }, this.lastPoint1 = { x: 0, y: 0 }, this.lastPoint2 = { x: 0, y: 0 }, this.distance = { x: 0, y: 0 }, this.lastDistance = { x: 0, y: 0 }, this.lastMove = { x: 0, y: 0 }, this.lastCenter = { x: 0, y: 0 }, this.tapCount = 0, this.points = [], this.pointers = [], this.dragDirection = "", this.isPointerdown = !1, this.singleTapTimeout = null, this.longTapTimeout = null, this.rafId = null, this.bindEventListener() } a.prototype.handlePointerdown = function (a) { "mouse" === a.pointerType && 0 !== a.button || (this.pointers.push(a), this.point1 = { x: this.pointers[0].clientX, y: this.pointers[0].clientY }, 1 === this.pointers.length ? (this.isPointerdown = !0, this.element.setPointerCapture(a.pointerId), this.tapCount++, this.dragDirection = "", this.points.length = 0, clearTimeout(this.singleTapTimeout), this.distance = { x: 0, y: 0 }, this.lastMove = { x: this.pointers[0].clientX, y: this.pointers[0].clientY }, 1 < this.tapCount && (30 < Math.abs(this.point1.x - this.lastPoint1.x) || 30 < Math.abs(this.point1.y - this.lastPoint1.y)) && (this.tapCount = 1), 1 === this.tapCount && (this.longTapTimeout = setTimeout(() => { this.tapCount = 0, this.options.longTap && this.options.longTap(a) }, 500))) : 2 === this.pointers.length && (this.tapCount = 0, clearTimeout(this.longTapTimeout), this.point2 = { x: this.pointers[1].clientX, y: this.pointers[1].clientY }, this.lastPoint2 = { x: this.pointers[1].clientX, y: this.pointers[1].clientY }, this.lastDistance = { x: this.distance.x, y: this.distance.y }, this.lastCenter = this.getCenter(this.point1, this.point2)), this.lastPoint1 = { x: this.pointers[0].clientX, y: this.pointers[0].clientY }, this.options.pointerdown && this.options.pointerdown(a)) }, a.prototype.handlePointermove = function (a) { if (this.isPointerdown) { this.handlePointers(a, "update"); const b = { x: this.pointers[0].clientX, y: this.pointers[0].clientY }; if (1 === this.pointers.length) this.distance = { x: b.x - this.point1.x + this.lastDistance.x, y: b.y - this.point1.y + this.lastDistance.y }, (10 < Math.abs(this.distance.x) || 10 < Math.abs(this.distance.y)) && (this.tapCount = 0, clearTimeout(this.longTapTimeout), "" === this.dragDirection && (this.dragDirection = this.getDragDirection())), this.points.unshift({ x: b.x, y: b.y, timeStamp: a.timeStamp }), 20 < this.points.length && this.points.pop(), this.handleDrag(a, b), this.lastMove = { x: b.x, y: b.y }; else if (2 === this.pointers.length) { const c = { x: this.pointers[1].clientX, y: this.pointers[1].clientY }; this.handleRotate(a, b, c), this.handlePinch(a, b, c), this.lastPoint1 = { x: b.x, y: b.y }, this.lastPoint2 = { x: c.x, y: c.y } } this.options.pointermove && this.options.pointermove(a), a.preventDefault() } }, a.prototype.handlePointerup = function (a) { this.isPointerdown && (this.handlePointers(a, "delete"), 0 === this.pointers.length ? (this.isPointerdown = !1, a._hasTriggerSwipe = !1, clearTimeout(this.longTapTimeout), 0 === this.tapCount ? this.handleSwipe(a) : (this.options.tap && this.options.tap(a), 1 === this.tapCount ? this.singleTapTimeout = setTimeout(() => { this.tapCount = 0, this.options.singleTap && this.options.singleTap(a) }, 250) : 1 < this.tapCount && (this.tapCount = 0, this.options.doubleTap && this.options.doubleTap(a)))) : 1 === this.pointers.length && (this.point1 = { x: this.pointers[0].clientX, y: this.pointers[0].clientY }, this.lastMove = { x: this.pointers[0].clientX, y: this.pointers[0].clientY }), a._distanceX = this.distance.x, a._distanceY = this.distance.y, this.options.pointerup && this.options.pointerup(a)) }, a.prototype.handlePointercancel = function (a) { this.isPointerdown = !1, this.tapCount = 0, clearTimeout(this.longTapTimeout), this.pointers.length = 0, this.options.pointercancel && this.options.pointercancel(a) }, a.prototype.handlePointers = function (a, b) { for (let c = 0; c < this.pointers.length; c++)this.pointers[c].pointerId === a.pointerId && ("update" === b ? this.pointers[c] = a : "delete" == b && this.pointers.splice(c, 1)) }, a.prototype.getDragDirection = function () { let a = ""; return a = Math.abs(this.distance.x) > Math.abs(this.distance.y) ? 0 < this.distance.x ? "right" : "left" : 0 < this.distance.y ? "down" : "up", a }, a.prototype.handleDrag = function (b, c) { b._dragDirection = this.dragDirection, b._diffX = c.x - this.lastMove.x, b._diffY = c.y - this.lastMove.y, b._distanceX = c.x - this.point1.x + this.lastDistance.x, b._distanceY = c.y - this.point1.y + this.lastDistance.y, this.options.drag && this.options.drag(b) }, a.prototype.handleSwipe = function (a) { let b = 0, c = 0; for (const d of this.points) if (200 > a.timeStamp - d.timeStamp) b = a.clientX - d.x, c = a.clientY - d.y; else break; 20 < Math.abs(b) ? (a._swipeDirection = 0 < b ? "right" : "left", a._hasTriggerSwipe = !0) : 20 < Math.abs(c) && (a._swipeDirection = 0 < c ? "down" : "up", a._hasTriggerSwipe = !0), a._hasTriggerSwipe && this.options.swipe && this.options.swipe(a) }, a.prototype.handleRotate = function (c, d, a) { c._rotate = this.getAngle(d, a) - this.getAngle(this.lastPoint1, this.lastPoint2), this.options.rotate && this.options.rotate(c) }, a.prototype.handlePinch = function (c, d, a) { c._scale = this.getDistance(d, a) / this.getDistance(this.lastPoint1, this.lastPoint2); let b = this.getCenter(d, a); c._centerX = b.x, c._centerY = b.y, c._lastCenterX = this.lastCenter.x, c._lastCenterY = this.lastCenter.y, this.lastCenter = b, this.options.pinch && this.options.pinch(c) }, a.prototype.handleWheel = function (a) { a._scale = 1.1, 0 < a.deltaY && (a._scale = .9), this.options.wheel && this.options.wheel(a) }, a.prototype.bindEventListener = function () { this.handlePointerdown = this.handlePointerdown.bind(this), this.handlePointermove = this.handlePointermove.bind(this), this.handlePointerup = this.handlePointerup.bind(this), this.handlePointercancel = this.handlePointercancel.bind(this), this.handleWheel = this.handleWheel.bind(this), this.element.addEventListener("pointerdown", this.handlePointerdown), this.element.addEventListener("pointermove", this.handlePointermove), this.element.addEventListener("pointerup", this.handlePointerup), this.element.addEventListener("pointercancel", this.handlePointercancel), this.element.addEventListener("wheel", this.handleWheel) }, a.prototype.unbindEventListener = function () { this.element.removeEventListener("pointerdown", this.handlePointerdown), this.element.removeEventListener("pointermove", this.handlePointermove), this.element.removeEventListener("pointerup", this.handlePointerup), this.element.removeEventListener("pointercancel", this.handlePointercancel), this.element.removeEventListener("wheel", this.handleWheel) }, a.prototype.destroy = function () { this.unbindEventListener() }, a.prototype.getAngle = function (c, a) { const b = c.x - a.x, d = c.y - a.y; return 180 * Math.atan2(d, b) / Math.PI }, a.prototype.getDistance = function (c, a) { const b = c.x - a.x, d = c.y - a.y; return Math.hypot(b, d) }, a.prototype.getCenter = function (c, a) { const b = (c.x + a.x) / 2, d = (c.y + a.y) / 2; return { x: b, y: d } }, a.prototype.getImgSize = function (a, b, c, d) { let e, f; return a / b >= c / d ? a > c ? (e = c, f = c / a * b) : (e = a, f = b) : b > d ? (e = d / b * a, f = d) : (e = a, f = b), { width: e, height: f } }, a.prototype.easeOut = function (a, b, c, d) { const e = c / d; return -(b - a) * e * (e - 2) + a }, a.prototype.raf = function (a, b = 300) { function c(g) { e === void 0 && (e = g); let h = g - e; h > b && (h = b, f++), 1 >= f && (a(h), d.rafId = window.requestAnimationFrame(c)) } const d = this; let e, f = 0; this.rafId = window.requestAnimationFrame(c) }, "function" == typeof define && define.amd ? define(function () { return a }) : "object" == typeof module && "object" == typeof exports ? module.exports = a : window.NonameGesture = a })();