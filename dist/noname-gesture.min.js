(function () { 'use strict'; function a(a, b) { this.element = a, this.options = b, this.point1 = { x: 0, y: 0 }, this.point2 = { x: 0, y: 0 }, this.lastPoint1 = { x: 0, y: 0 }, this.lastPoint2 = { x: 0, y: 0 }, this.distance = { x: 0, y: 0 }, this.lastDistance = { x: 0, y: 0 }, this.lastPointermove = { x: 0, y: 0 }, this.lastCenter = { x: 0, y: 0 }, this.tapCount = 0, this.points = [], this.pointers = [], this.dragDirection = "", this.isPointerdown = !1, this.singleTapTimeout = null, this.longTapTimeout = null, this.bindEventListener() } a.prototype.handlePointerdown = function (a) { if ("mouse" !== a.pointerType || 0 === a.button) { if (this.pointers.push(a), this.point1.x = this.pointers[0].clientX, this.point1.y = this.pointers[0].clientY, 1 === this.pointers.length) this.isPointerdown = !0, this.element.setPointerCapture(a.pointerId), this.tapCount++, this.dragDirection = "", this.points.length = 0, clearTimeout(this.singleTapTimeout), this.distance.x = 0, this.distance.y = 0, this.lastDistance.x = 0, this.lastDistance.y = 0, this.lastPointermove.x = this.pointers[0].clientX, this.lastPointermove.y = this.pointers[0].clientY, 1 < this.tapCount && (30 < Math.abs(this.point1.x - this.lastPoint1.x) || 30 < Math.abs(this.point1.y - this.lastPoint1.y)) && (this.tapCount = 1), 1 === this.tapCount && (this.longTapTimeout = setTimeout(() => { this.tapCount = 0, this.options.longTap && this.options.longTap(a) }, 500)); else if (2 === this.pointers.length) { this.tapCount = 0, clearTimeout(this.longTapTimeout), this.point2.x = this.pointers[1].clientX, this.point2.y = this.pointers[1].clientY, this.lastPoint2.x = this.pointers[1].clientX, this.lastPoint2.y = this.pointers[1].clientY, this.lastDistance.x = this.distance.x, this.lastDistance.y = this.distance.y; const a = this.getCenter(this.point1, this.point2); this.lastCenter.x = a.x, this.lastCenter.y = a.y } this.lastPoint1 = { x: this.pointers[0].clientX, y: this.pointers[0].clientY }, this.options.pointerdown && this.options.pointerdown(a) } }, a.prototype.handlePointermove = function (a) { if (this.isPointerdown) { this.handlePointers(a, "update"); const b = { x: this.pointers[0].clientX, y: this.pointers[0].clientY }; if (1 === this.pointers.length) this.distance.x = b.x - this.point1.x + this.lastDistance.x, this.distance.y = b.y - this.point1.y + this.lastDistance.y, (10 < Math.abs(this.distance.x) || 10 < Math.abs(this.distance.y)) && (this.tapCount = 0, clearTimeout(this.longTapTimeout), "" === this.dragDirection && (this.dragDirection = this.getDragDirection())), this.points.unshift({ x: b.x, y: b.y, timeStamp: a.timeStamp }), 20 < this.points.length && this.points.pop(), this.handleDrag(a, b), this.lastPointermove.x = b.x, this.lastPointermove.y = b.y; else if (2 === this.pointers.length) { const c = { x: this.pointers[1].clientX, y: this.pointers[1].clientY }, d = this.getCenter(b, c); a._centerX = d.x, a._centerY = d.y, a._lastCenterX = this.lastCenter.x, a._lastCenterY = this.lastCenter.y, this.handleRotate(a, b, c), this.handlePinch(a, b, c), this.lastPoint1.x = b.x, this.lastPoint1.y = b.y, this.lastPoint2.x = c.x, this.lastPoint2.y = c.y, this.lastCenter.x = d.x, this.lastCenter.y = d.y } this.options.pointermove && this.options.pointermove(a), a.preventDefault() } }, a.prototype.handlePointerup = function (a) { this.isPointerdown && (this.handlePointers(a, "delete"), 0 === this.pointers.length ? (this.isPointerdown = !1, clearTimeout(this.longTapTimeout), 0 === this.tapCount ? this.handleSwipe(a) : (this.options.tap && this.options.tap(a), 1 === this.tapCount ? this.singleTapTimeout = setTimeout(() => { this.tapCount = 0, this.options.singleTap && this.options.singleTap(a) }, 250) : 1 < this.tapCount && (this.tapCount = 0, this.options.doubleTap && this.options.doubleTap(a)))) : 1 === this.pointers.length && (this.point1.x = this.pointers[0].clientX, this.point1.y = this.pointers[0].clientY, this.lastPointermove.x = this.pointers[0].clientX, this.lastPointermove.y = this.pointers[0].clientY), this.options.pointerup && this.options.pointerup(a)) }, a.prototype.handlePointercancel = function (a) { this.isPointerdown = !1, this.tapCount = 0, clearTimeout(this.longTapTimeout), this.pointers.length = 0, this.options.pointercancel && this.options.pointercancel(a) }, a.prototype.handlePointers = function (a, b) { for (let c = 0; c < this.pointers.length; c++)this.pointers[c].pointerId === a.pointerId && ("update" === b ? this.pointers[c] = a : "delete" == b && this.pointers.splice(c, 1)) }, a.prototype.getDragDirection = function () { let a = ""; return a = Math.abs(this.distance.x) > Math.abs(this.distance.y) ? 0 < this.distance.x ? "right" : "left" : 0 < this.distance.y ? "down" : "up", a }, a.prototype.handleDrag = function (b, c) { b._dragDirection = this.dragDirection, b._diffX = c.x - this.lastPointermove.x, b._diffY = c.y - this.lastPointermove.y, b._distanceX = c.x - this.point1.x + this.lastDistance.x, b._distanceY = c.y - this.point1.y + this.lastDistance.y, this.options.drag && this.options.drag(b) }, a.prototype.handleSwipe = function (a) { let b = 0, c = 0; for (const d of this.points) if (200 > a.timeStamp - d.timeStamp) b = a.clientX - d.x, c = a.clientY - d.y; else break; (Math.abs(b) > 20 || Math.abs(c) > 20) && (a._swipeDirection = Math.abs(b) > Math.abs(c) ? 0 < b ? "right" : "left" : 0 < c ? "down" : "up", this.options.swipe && this.options.swipe(a)) }, a.prototype.handleRotate = function (c, d, a) { c._rotate = this.getAngle(d, a) - this.getAngle(this.lastPoint1, this.lastPoint2), this.options.rotate && this.options.rotate(c) }, a.prototype.handlePinch = function (c, d, a) { c._scale = this.getDistance(d, a) / this.getDistance(this.lastPoint1, this.lastPoint2), this.options.pinch && this.options.pinch(c) }, a.prototype.handleWheel = function (a) { a._scale = 1.1, 0 < a.deltaY && (a._scale = 1 / 1.1), this.options.wheel && this.options.wheel(a) }, a.prototype.bindEventListener = function () { this.handlePointerdown = this.handlePointerdown.bind(this), this.handlePointermove = this.handlePointermove.bind(this), this.handlePointerup = this.handlePointerup.bind(this), this.handlePointercancel = this.handlePointercancel.bind(this), this.handleWheel = this.handleWheel.bind(this), this.element.addEventListener("pointerdown", this.handlePointerdown), this.element.addEventListener("pointermove", this.handlePointermove), this.element.addEventListener("pointerup", this.handlePointerup), this.element.addEventListener("pointercancel", this.handlePointercancel), this.element.addEventListener("wheel", this.handleWheel) }, a.prototype.unbindEventListener = function () { this.element.removeEventListener("pointerdown", this.handlePointerdown), this.element.removeEventListener("pointermove", this.handlePointermove), this.element.removeEventListener("pointerup", this.handlePointerup), this.element.removeEventListener("pointercancel", this.handlePointercancel), this.element.removeEventListener("wheel", this.handleWheel) }, a.prototype.destroy = function () { this.unbindEventListener() }, a.prototype.getAngle = function (c, a) { const b = c.x - a.x, d = c.y - a.y; return 180 * Math.atan2(d, b) / Math.PI }, a.prototype.getDistance = function (c, a) { const b = c.x - a.x, d = c.y - a.y; return Math.hypot(b, d) }, a.prototype.getCenter = function (c, a) { const b = (c.x + a.x) / 2, d = (c.y + a.y) / 2; return { x: b, y: d } }, a.prototype.getImgSize = function (a, b, c, d) { let e, f; return a / b >= c / d ? a > c ? (e = c, f = c / a * b) : (e = a, f = b) : b > d ? (e = d / b * a, f = d) : (e = a, f = b), { width: e, height: f } }, "function" == typeof define && define.amd ? define(function () { return a }) : "object" == typeof module && "object" == typeof exports ? module.exports = a : window.NonameGesture = a })();